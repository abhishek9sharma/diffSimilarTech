syntax, clearer, wise, ---------------------------------------------------

clearer,beginners,syntax
i m just adding this below in objective-c to make it clearer to beginners and those of us who refuse to learn swift syntax

new,syntax,wise
im new to swift but i like it more than objective-c as it looks a bit like java does to me from syntax wise compared to objective-c

successor,comfortable,syntax
however i read that swift was the successor of objective-c and i would feel more comfortable with swift syntax

faster, slower, things, ---------------------------------------------------

solution,2x,slower,cocoa,equivalent
still technically yes it appears that an all swift solution is roughly 2x slower than a swift + cocoa solution which should be roughly the same than objective-c + cocoa when compiled with equivalent options iirc

chunks,uikit,change,faster
if you are using something like paintcode or have large chunks of uikit code in swift change it to objective-c it compiles far faster

esoteric,things,harder
some esoteric things you are used to with objective-c are harder to implement with swift

slower,top
wouldn t swift be slower than objective-c in this case since it is layered on top of it

things,faster
i have tried many things already changing up a few things wrote in swift differently alternatively using a for instead of the built in contains in swift to see if that might be the problem but objective-c was still faster

view,faster,performance,slower
my view is that if in some cases objective-c is faster than swift it doesn t mean that all over performance of swift is slower

craig,announcement,faster
as craig revealed within the announcement of swift it is said to be faster than objective-c by far

executable,size,application,bigger
executable size of swift application is much bigger than size of objective-c application

processing,compiler,faster
most importantly for your image processing app the compiler will optimize swift code to run faster than objective-c

compiler,names,intricate,method
fwiw the objective-c compiler also mangles names but swift s mangling is more intricate to allow for method overloading etc

application,harder,possible
injecting code in a swift application is harder than it was for an objective-c application but it s still possible

simple,conclusions,faster
bottom line i would personally hesitate to draw any simple conclusions of swift is faster than objective-c or vice versa

compiler,newer,unlikely
the swift compiler is doing a lot more and is quite a bit newer than the objective-c compiler so it unlikely it will be as stable fast for quite some time

apple,faster
and also apple does might not confidently announce that swift is more faster than objective-c in all the cases

possible,faster,pure,things
it is possible for swift to be faster than pure objective-c in things that you would traditionally use c or c++ for anyway

ridiculous,apple,faster,low,level
the perf hit will be ridiculous i know apple say swift execute faster than objective-c but this is low level so it will be harmless

slower,implementation
the swift one is dramatically slower then objective-c implementation

tests,certainty,faster,slower
i don t think that as of today you can run these tests and determine with any certainty whether swift 1.0 is faster or slower than objective-c

compiler,imports,things
swift s compiler is also doing a lot more than objective-c s compiler considering swift is more strongly typed and does not required specifying imports among other things

multiple,slower
there are multiple reasons why the swift code is slower than the objective-c code

application,fine,comfortable,unit
i have a objective-c application working fine and smooth to be more comfortable with swift i decided to write the unit tests for this app in swift

comments,possible,libraries,pure,solution
as mentioned in the comments although its possible to use objective-c libraries in swift i wanted a more pure swift solution

type, stricter, dynamic, ---------------------------------------------------

better,aspects,major,dynamic,libraries,older,version
i feel swift is better than objective-c in many aspects but my major question is - will swift dynamic libraries support older version of swift

stricter,runtime,type,correctness,duck,typing
swift is stricter about runtime type correctness than objective-c so duck typing alone is not enough

lax,type,checking,easy,stricter
objective-c s relatively lax type checking makes this easy to deal with but swift is stricter

optional,type,safer,nil
apple seems to claim that the optional type in swift is safer than nil in objective-c but i don t understand why this is so

free,easy,compilation,checks
objective-c is much more free and easy with types and compilation checks where swift isn t

good,dynamic,type,inspection,better,compiler
while objective-c was good at dynamic type inspection swift is much better of you allow the compiler to do the type checking at compile time

readable, print, ---------------------------------------------------

readable
with swift the code is much more readable than with objective-c

print,readable
objective-c print is more readable compared to swift

better, easier, familiar, ---------------------------------------------------

parent,class,property--this,better,approach
swift also prevents us i believe from overriding a parent class s property but also still lets us observe changes to that property--this is much better than objective-c s approach

better
better if you have a code swift is better but is not problem objective-c

enumerations,better
enumerations in swift 2 are much better then in objective-c

singleton,class,easier
as you can see defining a singleton class in swift is much easier than in objective-c

month,fun,easier
early this month i started learning swift as i found it fun and easier than objective-c

safer,safe
swift in that case would not be safer but less safe than objective-c

easier,transition
i don t know objective-c all that well and swift would be an easier transition i feel

hand,easier,background,time
on the other hand swift is easier to learn especially if you have objective-c background so it can be adopted during the time slowly and paralelly with using objective-c

better
so i ve started learning swift because it looks way better than objective-c

familiar,life,figure
i m learning swift and much less familiar with objective-c but for the life of me i can t figure out how they are trying to achieve the goal stated as build list of encodings sorted and including only those with human readable names.

familiar,chance
i m more familiar with objective-c than swift and haven t had a chance to test this yet but this should be close

smarter,singleton,class
swift is lot smarter than objective-c about singleton class

method,cleaner,init,methods
usually i find swift s method naming to be cleaner than objective-c s but init methods can be an exception

apps,unfamiliar,familiar
this article seems to suggest that this is possible by swizzling a fake location into apple s cllocationmanager class to be used by other apps but i am unfamiliar with the objective-c code more familiar with swift

helpful,familiar,method
in case it s helpful since you seem perhaps more familiar with objective-c than swift here s what your swift method would look like if we translated it back into objective-c

easier
swift is neither easier to read nor understand than objective-c

static,method,class,foundation
we ve seen that swift uses a more static method dispatch than objective-c which unless a class dervices from foundation nsobject prevents the style of swizzling based on remapping method implementations at runtime

interested,solution,important
i would be very interested in seing the solution in objective-c also but swift is more important for me here

conversion,better,days
i m trying to make the conversion from objective-c to swift and have had better days

better,delegate
so in swift just as in objective-c you had better make that delegate property weak because it would be terrible if one view controller suddenly took memory management ownership of another view controller

enums,powerful,equivalents
i know that swift enums are much more powerful than their objective-c equivalents

metal,better
i suppose it sort of makes sense to do things this way except for the fact that metal appears to play better with objective-c even though it looks like swift

posts,typedef,better,solution
after thinking about playing with it some more and reading some other posts using objective-c typedef in swift here is a better solution i think

simpler,beginners,months,complicated,better
it seems to me that swift would be way simpler to learn then objective-c for beginners i know because i learned it in like 2 months and swift is less complicated and better laid out then objective-c

generics,regard,better
but we can assume that generics in objective-c were introduced for transitioning to swift and in that regard using swift directly is even better

arrays,floats,++,easier
then the buffers won t need to be treated as arrays of pointers and passing arrays of say floats between objective-c ++ and swift is easier

note,arrays,sensible
note that swift s arrays are much more sensible than objective-c s

use, ---------------------------------------------------

use
i use objective-c more than swift

use
also note that i use objective-c more than swift

applications, macos, structs, ---------------------------------------------------

professional,work,enterprise,applications
writing swift 2.0 in my professional work my personal opinion is that it s indeed ready for enterprise applications -- maybe even more than objective-c ever were

older,programming,macos,applications,structs
as objective-c is the older programming language for ios or macos applications swift allows you to use those classes structs in your code

others---------------------------------------------------


i also use objective-c more than swift but here s what my guess is as to what the objective-c code would come to

students,property,means,different,dedicate,method,clear
for example exposing the students property in swift means different places can all modify it and the delegate would be notified also it s not clear to the coder that setting students property would trigger a delegate notification for averagescore whereas having a dedicate method in objective-c makes it more clear

designers,trouble,constraints,wish
the swift designers went through a lot of trouble to make sure that it s more than just objective-c without the constraints of c in fact i almost wish they hadn t said that since it s so often misquoted

answer
edit although this answer works it is little more than objective-c transliterated into swift

blocks,closures,loose
objective-c blocks and swift closures are more than loose equivalents

-documentary,content,documentary
objective-c -documentary provides more content than the documentary for swift

verbose,doubt,asking,broad,likely,messagecomposer,object,regard,usage
java tends to be much more verbose than swift so i doubt what i m asking is too broad it is more likely that i don t know how to use the objective-c messagecomposer object because the documentation that i linked to above is unclear with regard to usage in swift

runtime,smaller
the swift runtime is smaller than the objective-c runtime

example,complex,error,prone
as you can see the swift example is more complex and error prone than your objective-c code

accurate,timing
i saw this swift vs objective-c and it does lead me to believe that swift is more accurate in terms of timing that objective c but i wanted to make sure that was accurate

legal,procedural,style
personally i prefer objective-c because you can use c very easily as anything that is legal in c is also legal in objective-c added to which swift is a more procedural in style where objective-c is quite clearly object orientated

secure
one of the reasons we want to move is because swift is more secure than objective-c

order,correct,type-safe,possibility,unrecognized
so it should have always been gkagent under objective-c in order to be strictly correct however objective-c is less type-safe than swift so you could get away with it with the possibility that you d get an unrecognized selector exception if a gkagent object was ever passed to the delegate method and you assumed it was a gkagent2d

vvcospif,wrapper,runtime,data,intel,simd,slower
may be because vvcospif it is wrapper under objective-c runtime and converting data structures copying of memory from intel simd - objective-c - swift runtime is slower then tiny cos


objective-c has been updated to enable it and swift to work together more easily and efficiently

attributes,understandable,complier,rule
those attributes let you create objective-c code which is more understandable by swift and complier warn you when you break the rule for example

clearer,versions,releases,related,information
swift is clearer on versions releases and i keep asking myself if i am missing something related to objective-c since i can t find this information

possible
specifically it makes it possible to write objective-c code that plays nicely with swift which is more strongly typed than objective-c

objects,existence
no objects come magically into existence in swift any more than in objective-c


swift is more strictly typed than objective-c

emphasis,subclassing
in swift as objective-c there is far less emphasis on subclassing than other languages

bundles,mb,larger,counterparts
you will notice that swift bundles are always about 4-5 mb larger than their objective-c counterparts and this is precisely why

dictionary,nsdictionary
this is because the swift dictionary is more strongly typed than the objective-c nsdictionary

lightweight,generics,api,easier,interface
adding lightweight generics to your objective-c api makes it easier to interface with swift because your api gets translated more precisely

robust,modern,stronger,typing
swift won t allow you to do absolutely everything that objective-c does but it will allow you to do almost everything and the code will be probably more robust considering that swift is more modern language with stronger typing than objective-c

benefits,strings,tuples,compound
swift comparing to objective-c has it s own benefits like swift handles strings more easily swift tuples offer compound variables and also coders don t need to spend time annotating variables with type information and risk making mistakes

switch,methods,longer,visible
however when i switch to swift 4.0 the methods declared in swift is no longer visible in objective-c

move,prudent,secure
while i think the move to swift is prudent but i think it overstates the case to argue that swift is significantly more secure that objective-c

nicer,core,audio
i find that objective-c is much nicer for working with core audio than swift

earlier
i m writing some swift 1.2 code that calls an objective-c library transcribing some earlier objective-c code

buggy,heck,ill,bet,worse,benefits,couple,years,equal,greater,basic,simplicity
i know that swift is buggy as heck i run into bugs everyday but ill bet objective-c was even worse when it started out benefits of hindsight so in a couple of years swift will be equal or greater than objective-c keeping its basic simplicity as well

penalty,fewer,situations,instance,method,objc_msgsend,protocol,objects,methods
swift will incur this penalty in fewer situations than objective-c will for instance method calls to swift-only protocol methods do not hit objc_msgsend but if the protocol is declared in objective-c or if the swift protocol is decorated with objective-c such that it can be adopted by objective-c objects as well then method calls to methods in that protocol adopted by swift objects appear to be dispatched via objc_msgsend

able,exceptions,parser,github
with objective-c i was able to catch all the exceptions thrown by the parser found on github but with swift we are no more allowed to do so and therefore my question

corrections,welcome,guy
any swift corrections are more than welcome i m still an objective-c guy for now

pointers,present
it al has to do with pointers which were very present in objective-c but are much more hidden in swift

limited,experience,common,use-case
in my limited experience using objective-c code from swift is a more common use-case and fairly trivial

support,reflection
but swift is less dynamically typed than objective-c and has less support for reflection

related,articles,effective
after reading some related articles i don t think swift is more effective than objective-c

long,term,interface,annotated
i n the long term every objective-c interface ought to be explicitly annotated so that swift can import them more precisely

dynamic,stuffs
swift seems to be less dynamic than objective-c in these stuffs

type,system,strict,static,metatypes,special
self is a type constraint not an actual type. this is a side effect of the type system in swift being much more strict and static than that of objective-c for example metatypes aren t just a special flavor of otherwise normal objects

larger,issue,interfaces,extensions,project,understanding
however i suspect i m having a larger issue with using objective-c interfaces with extensions in a swift project or my understanding of how that works

stricter,initialisers
furthermore swift is stricter than objective-c when it comes to initialisers

