subtraction, character, higher, ---------------------------------------------------

divide,higher,precedence
multiplying and divide have higher precedence than add and subtract

precedence,subtraction,digit,character
since multiplication has a higher precedence than subtraction you should subtract 0 to your digit character before multiplying it

parameter, greater, first, ---------------------------------------------------

first,field,value,greater
subtract first field from the other and if the value is not greater than 0 multiplying by -1

parameter,greater,lambda,interpolated,color
if the parameter is greater than 0.5 multiplying lambda by two and subtract one this maps onto and return the interpolated color between color b and color c

others---------------------------------------------------

particular,chunk,divide,modulo,time,greater
but my guess would be that in this particular chunk of code multiplying divide and modulo all take roughly the same amount of time and that time is greater than add or subtract

numerals,digits,values,power,better,result
if you have some binary floating-point values a and b that you know are very near decimal numerals with a few digits then multiplying those values by a power of ten subtract and dividing by the power of ten generally does not provide a better result than simply subtract the values directly

words,slower,enough
in other words hardly anything slower than multiplying add subtract but not enough to really worry about

logic,whole,number,bigger
the logic is multiplying by 2 whole number 0.1 2 0.2 and if it s bigger than 1 subtract and continue

faster
subtract is faster than multiplying

integer,instructions,lower,latency
integer add subtract compare instructions but not multiplying are also lower latency than their fp counterparts

logarithms,factorials,end,reliable
adding and subtract logarithms of factorials then taking the exponential at the end is more reliable than multiplying and dividing factorials directly

extent,cluster,lcn,size,next,number,greater,current
when you have multiple extents you can figure out on which extent the cluster is by multiplying the lcn with the size of a cluster and then subtract the size of each extent returned by the ioctl in the order they are returned if the next number to subtract is greater than your current number that particular lcn is on that extent

n-5,time,constant,weaker
similarly if you skip the five first elements your loop takes o n-5 time but that too is the same as o n because adding or subtract a constant is even weaker than multiplying by a constant

higher,precedence,example,john
to give multiplying and divide higher precedence than add and subtract you can do something like this example adapted from john levine lex yacc 2 e 1992

compiler,bitshift,faster
p is sometimes chosen to be 31 because not only is it prime but a compiler resolves it to a bitshift and a subtract which is much faster than a multiplying

calculator,functions,like,necessary
the code is used to create a calculator that shall have functions like squaring rooting subtract adding multiplying dividing and more if i feel like is necessary in the future

