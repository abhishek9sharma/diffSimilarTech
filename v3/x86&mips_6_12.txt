output, complex, architecture, ---------------------------------------------------

care,output,complex
the wording in your question seems to suggest you don t care as much that the output is mips but rather you want the output to be less complex than x86

assembly,architecture,complicated
i have studied the x86 assembly and architecture and it appears to be a lot more complicated than mips

complex,instructions
x86 have more complex instructions than mips

arm, intel, architectures, ---------------------------------------------------

architectures,arm,easier,instruction,set
do any of the other common architectures like arm mips sparc etc have an easier than x86 instruction set

assembly,easier,b,data
if you have not programmed assembly before i suggest you choose mips since it is easier than x86 and then b looking at how to transfer data with the serial port to begin with since this illustrates memory-mapped i o that is used

emulator,nicer,assembly,set,intel,32-bit
this could include a emulator for a 68000 or mips which are arguably nicer assembly instruction sets than the venerable cisc instruction set of the intel x86 16 32-bit

others---------------------------------------------------

monster
if you pick up something like mips and get the hang of it x86 is less of a monster to learn

exceptions,register,usage,nothing,worth
x86 have more exceptions for register usage than mips that you have to keep in mind but nothing worth whining about constantly

bet,spim,assembly,straightforward,anyways
a better bet might be to install spim and to learn mips assembly which is more straightforward than x86 anyways

orthogonal
mips is much more orthogonal than x86 could ever dream of being

edx,eax,rdx,rax,v0,v1,assembler,register
however in most computer architectures there are at least 2 registers to return values that are twice or more as wide as the word size edx eax in x86 rdx rax in x86_64 v0 and v1 in mips why mips assembler has more that one register for return value

lower,clock,faster,newer,ones,chip
yes it is very true that an x86 can have a lower clock and run faster than some other x86 historically the newer ones can do less stuff per clock than older ones for the same binaries you have to then tune the compile to the newer chip and then you might get back some of your mips to mhz

