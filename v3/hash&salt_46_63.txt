username, cost, long, ---------------------------------------------------

lack,harder,password
the lack of salt is harder to expoit here than with password hash since the hash is not directly known

passwords,harder,attacker
hash passwords with salt are much harder for an attacker to use than a plaintext password which they can use with the right username

harder,original,someone,database
the salt shall make it harder to find the original password with a rainbow-table in case someone could steal your database with the hash

hard-coded,popular,rainbow,tables,easier,product
if the salt is hard-coded into a popular product lookup tables and rainbow tables can be built for that salt to make it easier to crack hash generated by the product

consistency,checks,security
if hash are used for more than consistency checks licensing one could use salt and encryption to increase security

sha-256,passwords,md4
now personally i generally use a salt sha-256 hash on my passwords because i thought that md4 and md5 were no longer secure and that hashing a password multiple times would just put too much strain on a server for no practical benefit

cost,data,larger,value
likely not as cheap as xor against n values but seems like there s possibility for better quality results at a minimal extra cost especially if the data being hash is much larger than the salt value

randomness,characters,better,several
the more randomness and more characters your salt has the better for the hash but anything that s several characters long and random works

attacks,common,passwords,harder,usernames,numbers
most attacks involve generating hash for common passwords so for reasonably complicated passwords it becomes harder especially with salt some people use usernames as salt others use randomly generated numbers

situation,password,secure,credentials,hands
in this situation storing password hash and the salt is more secure than storing the credentials encrypted or not because an attacker would have no way of getting the password back even if he manages to get his hands on both the hash and the salt

difficult,attacker,passwords
you use a salt to make it more difficult for the attacker to get at your passwords because then he would need to know the salt so that he can use it in computing the hash for your passwords

string,hard,password,longer,long,time
you can safely store the salt in the db because working out a string from its hash is just as hard when you know some of the string as it is when you know none of it provided the password itself is longer than the salt and long enough and strong enough to take a long time to crack by brute force at least 6 chars with at least one case change and a number or non-alphanumeric i d say

data,unique,faster,need,username
you ll probably need to get data anyway so the unique salt is probably faster too because you won t need to calculate the hash over username

password,+,better,good
hash password + salt is better but still not good enough.

nothing,random,string,passwords,password,unique
this salt is nothing more than a random arbitrary string that you concatenate to the passwords and it will make your hash password unique

greater,amount,access,password,order,database
it is true that randomly generated salt produce a greater amount of security but it is also true that anyone who gets access to a list of your password hash in order to crack them probably has access to your database in which case they have access to your salt

result,length,harder,history,hacker
i don t know how safe could it be and how difficult is for the hacker to determinate the technique i use the thing is that the result has the same length as the hash and is harder to determinate a salt so if for any reason in the history hacker uses a rainbow table and catches a probable result it will be the wrong

harder,attacker,dictionary,per-user
salt just make it harder by forcing an attacker to hash the dictionary on a per-user effectively per-salt basis

example,field,characters,longer,trimmed,password
example the salt field might only allow a 64 characters while the generated salt might be longer therefore when you save the salt it gets trimmed which ultimately changes the hash password

impression,passwords,secure,company,operations
i get the impression that most people think that hashing salt passwords is the more secure way of handling passwords but i can t figure out a way to comply with current company operations when using hash passwords

md5,secure,better,sha256managed
with a salt md5 is much more secure than without but you re better off using one of the sha hash such as sha256managed

algorithm,cost,life,harder,hackers,safer
it is supposed i think that the algorithm cost and salt is used to make the life harder to hackers and if i use that my hash will be safer

password,functions,use,harder,hacker
i ve been reading about password hash functions and it s said use a salt to make harder the hacker s work use a height cost algorithm etc

beginning,better,randomness
putting the salt at the beginning is better than putting it at the end as more randomness at the beginning of hash is better than randomness at the end

#2,plain,sha-1,sha-2
as a side note from what i ve read key derivation functions pbkdf2 scrypt bcrypt are considered better more secure #1 #2 than plain salt sha-1 sha-2 hash by crypto people

passwords,common,practice,nonce,better,secret
in storing hash passwords is a common practice to add a nonce or a salt and is marginally true that this salt is better kept secret

value,safer,someone
using the hash value with a salt is much safer if someone breaks into your db no password is there

passwords,password,random
never store passwords instead store password hash and random salt read more

password,security,secure,plain
hash password by using security salt is more secure than plain text password

extra,level,complexity,harder,brute-force
salt is used to add an extra level of complexity to the hash to make it harder to brute-force crack

original,long,trimmed,invalid,password,easier,collision
since the hash is generated using the original long salt using a trimmed salt later would just yield an invalid hash when specifying the original password - it doesn t make it any easier to find a hash collision

sha-512,higher,security,scheme,better,high
salt sha-512 offers a higher level of security and implementing a scheme where you stretch the hash is even better do some high number of iterations of sha-512 - starting with the password+salt of course

password,longer,security,good,collisions
if their original password was longer than the salt + hash you may have just reduced the security of their password assuming a good password and ignoring hash collisions

correct,password,passwords,database,link
if we are talking about passwords where you only need to know if the user entered the correct password or not then you could hash the passwords with a salt and compare with the database hash read more about that here link

secure,random,user,expensive
the hash can be more secure you can have random salt for every user which makes it computationally expensive for someone to brute force attack the passwords should the database be compromised

use,sha-512,bigger,number,name,better
personally i use sha-512 with a salt because a bigger number in the hash name means a better hash

time,better,iterations
the time to hash the salt you spend better in doing more iterations on the password hashing

purpose,harder,someone,codes,able
keep in mind the purpose of the salt to make it harder for someone to precalculate hash codes and therefore be able to look up passwords in the case of the database being compromised

strong,cryptographic,function,secure
you should use a strong cryptographic hash function and a salt to make it more secure

internet,millions,values,easier,rainbow,tables,use
there are lists available on the internet with millions of already hash values to make hash cracking easier those are known as rainbow tables and they can be easily countered with the use of salt

intensive, brute, match, ---------------------------------------------------

dynamic,user,datastore,version,cpu,intensive,function,secure,likely
adding a dynamic salt to each user would mean that you will have to hit a datastore to retrieve the dynamic salt and the hash version of the user s password then you will have to perform the cpu intensive hash function in your code twice -- you are hashing a hash which is less secure and more likely to have collisions

careful,easy,secure,h,password,weaker,time,effort
as others have mentioned you want to be careful with your hash since it s easy to do something that s not really secure h salt password is far weaker than h password salt but at the same time you want to balance the effort put into this with the value of the site content

value,random,number,match,dictionary,passwords,possible,values,difficult
by using a salt value typically you want this to be a random number the hash won t match the dictionary the chance of them pre-calculating all passwords with all possible salt values is exponentially more difficult

password,crypt,secure,brute,output,hackers,passwords
so when i see that the salt is stored in the hash password and that you use that hash password as salt i think crypt + salt is not more secure against a brute force on output hackers who managed to steal hash passwords

simple,md5,user,login,end,system,passwords,secure
actually you can insert the passwords as a simple md5 hash it will still work for letting the user login though it is recommended to then change the password through the front end system as the salt passwords are more secure

django,passwords,pbkdf2,bcrypt,session,complex,hmac,random
in django for example passwords are hash with pbkdf2 or bcrypt but session hash use a less complex hmac and no random salt

others---------------------------------------------------

restructuring,database,field,better,currant,person
restructuring of the database to just add an salt field is better option or the only one really if your going to do it properly but you could use your currant hash field to store the salt as other person posted

hmac,better,pbkdf2,safe,broken,function
an hmac is a better way of adding your salt and pbkdf2 is based on hmac - see below for more detail on pbkdf2 - there s a good discussion at when is it safe to use a broken hash function

first,lack,value,users,password,easier,multiple
the first problem is obviously the lack of a salt value which means if 2 users have the same password they will have the same hash which makes it easier to compromise multiple accounts

sha1,cycles,unhash,use,rainbow
i think i understand the purpose of using sha1 as it s supposed to require more cycles than md5 to hash unhash and the salt is supposed to prevent the use of rainbow tables

guessable
the hash will be no more easily guessable wherever you put the salt

encypted,method,safer,good,past,md5
using a encypted method with a salt would be even safer but this would be a good next step past just using a md5 hash

initial,thought,different,algorithm,collision,resistant
my initial thought is that 2 hash either using 2 different algorithms or the same algorithm twice with 2 salt would be more collision resistant

pbkdf2,applies,function,large,number,long,important,traditional,byte,random,unique,users
although because pbkdf2 applies your hash function a large number of times a long salt is less important than in traditional straight hashing applications. for my application i use a 32 byte random salt unique for each users account where i m hashing their password with pbkdf2

different,secure
i read somewhere that adding a different salt to each hash makes it more secure

simplest,form,user,passphrase,sha-2,256-bit,scrypt,harder
the simplest form of this is to add a salt to the user s passphrase and then feed it into sha-2 to get a 256-bit hash but ideally you want to use something like scrypt to make it harder to brute-force the passphrase

powerful,seed,internal,state,multiple,size,alignment,input,function
prepending a salt is also more powerful than directly setting the seed values because in addition to changing the internal state of the hash if the salt is not a multiple of the digest block size then it can also perturb the alignment with which the input is fed into the hash function

nothing,earlier
that accepts either nothing a salt or a hash that crypt made earlier which has the salt to make the hash embedded in it

revere,sengineering,aware
you can use salt to get a more revere sengineering aware hash

simpler,deals,completelly,transparent,updates,algo,time,cost
it s simpler deals with salt for you in a completelly transparent way makes way for updates both in encryption algo and in hash time cost and comes bundled in a nice api

protection,rainbow,tables,worth
however using a salt offers more protection against rainbow tables precalculated hash tables so they re still worth using

pbkdf2,bit,byte,random,higher,iteration
just use pbkdf2 to make your hash directly make a 64 bit 8 byte random salt use a higher iteration count 4000-10000

accesses,md5,apache,password,different,thinking,characters,security
having looked at the existing accesses listed i can see that it doesn t appear to be using the salt md5 hash that s stated in the apache docs the hash password that s stored is different to what i m thinking i should expect the salt is significantly more than 2 characters and for security reasons i m reluctant to embed a particular password hashing algorithm in my code

