compilation,phase,more,complex,dfas,capabilities
at the same time the compilation phase for a dfa is typically more complex than for an nfa and dfas don t have all the capabilities of nfas

many,simple,smaller,way
in fact because you are eliminating the redundancy of epsilon transitions many simple dfa s actually get smaller than the nfa they represent but there is simply no way to guarantee that

better,traditional,more,expressive,implementations,regexes,word,characters
the net effect is that the backtracking implementations i like that name better than traditional nfa are slightly more expressive than dfa implementations because they can match regexes like which matches three or more word characters repeated twice something that can t be matched by a dfa

combinations,states,more,thing
if we express combinations of states in an nfa as states themselves we ve got a dfa with a lot more states than the nfa but which does the same thing

better,choice,transition,input,many
dfa is a better choice over nfa because it has only one transition for an input while nfa can have many

representation,problem,easier,equivalent
because representation of a given problem with a nfa is far easier than the equivalent dfa

perl,slower,more,powerful,engine
perl uses nfa which is slower yet more powerful than the dfa engine sed has

larger,means
if it can be practically determinized this give you a dfa that can be exponentially larger than the nfa then by all means do that

speaking,faster,more,compact
generally speaking dfa is faster but nfa is more compact

regex,slower,hand-written,parser
regex is a nfa and is as such in most cases slower than a dfa or hand-written parser

regex,slower,hand-written,parser
regex is a nfa and is as such in most cases slower than a dfa or hand-written parser

many,simple,smaller,way
in fact because you are eliminating the redundancy of epsilon transitions many simple dfa s actually get smaller than the nfa they represent but there is simply no way to guarantee that

compilation,phase,more,complex,dfas,capabilities
at the same time the compilation phase for a dfa is typically more complex than for an nfa and dfas don t have all the capabilities of nfas

combinations,states,more,thing
if we express combinations of states in an nfa as states themselves we ve got a dfa with a lot more states than the nfa but which does the same thing

representation,problem,easier,equivalent
because representation of a given problem with a nfa is far easier than the equivalent dfa

faster,more,compact
generally speaking dfa is faster but nfa is more compact

larger,means
if it can be practically determinized this give you a dfa that can be exponentially larger than the nfa then by all means do that

perl,slower,more,powerful,engine
perl uses nfa which is slower yet more powerful than the dfa engine sed has

better,choice,transition,input,many
dfa is a better choice over nfa because it has only one transition for an input while nfa can have many

better,traditional,more,expressive,implementations,regexes,word,characters
the net effect is that the backtracking implementations i like that name better than traditional nfa are slightly more expressive than dfa implementations because they can match regexes like which matches three or more word characters repeated twice something that can t be matched by a dfa

faster,more,compact
generally speaking dfa is faster but nfa is more compact

compilation,phase,more,complex,dfas,capabilities
at the same time the compilation phase for a dfa is typically more complex than for an nfa and dfas don t have all the capabilities of nfas

larger,means
if it can be practically determinized this give you a dfa that can be exponentially larger than the nfa then by all means do that

combinations,states,more,thing
if we express combinations of states in an nfa as states themselves we ve got a dfa with a lot more states than the nfa but which does the same thing

better,traditional,more,expressive,implementations,regexes,word,characters
the net effect is that the backtracking implementations i like that name better than traditional nfa are slightly more expressive than dfa implementations because they can match regexes like which matches three or more word characters repeated twice something that can t be matched by a dfa

representation,problem,easier,equivalent
because representation of a given problem with a nfa is far easier than the equivalent dfa

perl,slower,more,powerful,engine
perl uses nfa which is slower yet more powerful than the dfa engine sed has

regex,slower,hand-written,parser
regex is a nfa and is as such in most cases slower than a dfa or hand-written parser

transitions,simple,smaller
in fact because you are eliminating the redundancy of epsilon transitions many simple dfa s actually get smaller than the nfa they represent but there is simply no way to guarantee that

better,choice,transition,input
dfa is a better choice over nfa because it has only one transition for an input while nfa can have many

