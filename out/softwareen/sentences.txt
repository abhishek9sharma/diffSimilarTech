573
goto	break
pattern0	simpler	
if you re in a nested loop and need to break out of all loops a goto can make this much cleaner and simpler than break statements and if-checks

8704
firefox	safari	opera	firefox	opera	safari
pattern7	
using opera would mean develop in opera then test in ie safari and firefox . just means more work for you to do

8704
firefox	safari	opera	firefox	opera	safari
pattern7	
using opera would mean develop in opera then test in ie safari and firefox . just means more work for you to do

12390
cvs	svn
pattern7	
bro use a versioning control system svn git mercurial even old cvs is better than nothing

12390
cvs	svn
pattern7	
bro use a versioning control system svn git mercurial even old cvs is better than nothing

18345
folder	directory
pattern0	
unless you ll need more than 65534 folder per directory you should be okay apparently this is the maximum for ntfs

25039
imperative	declarative
pattern8	more intuitive	
i can t find the right post anymore but eric lippert and possibly several other softies have opined on several occasions about how linq is declarative which for several classes of problems is far more intuitive than imperative syntax

28259
serializable	deserialization
pattern10	
reflexion distributed computation requires serializable which should be left to the compiler and deserialization is more easily achieved with some form of reflexion

28259
serializable	deserialization
pattern10	
reflexion distributed computation requires serializable which should be left to the compiler and deserialization is more easily achieved with some form of reflexion

28497
vim	emacs
pattern0	less	
i know emacs most than others vim a little less than emacs and knows where to click in visual studio

29073
ant	maven
pattern10	approach more	
the maven approach is more declarative than ant

29073
ant	maven
pattern10	approach more declarative	
the maven approach is more declarative than ant

29073
ant	maven
pattern8	more declarative	
the maven approach is more declarative than ant

33043
children	parent
pattern0	
heap-like ordering means that both children of a parent have lower priorities than the parent

39357
ironruby	ironpython
pattern10	
imo a language like python ironpython or jython if the host system is .net or java or ruby ironruby jruby is better for basing your dsl on than java or c#

39357
ironruby	ironpython
pattern10	
imo a language like python ironpython or jython if the host system is .net or java or ruby ironruby jruby is better for basing your dsl on than java or c#

40505
getter	setter
pattern7	
if it s a set of getter and setter that s better but still not great

40505
getter	setter
pattern7	
if it s a set of getter and setter that s better but still not great

41738
x86	mips
pattern10	
if you have mips i believe its better for teaching but i suppose x86 is more convenient since it is more widespread x86_64 better since has more registers and niceties

41738
x86	mips
pattern10	
if you have mips i believe its better for teaching but i suppose x86 is more convenient since it is more widespread x86_64 better since has more registers and niceties

52697
minix	linux
pattern10	
i use and have used linux in production for 16 years and love it but since it s a production quality highly-tuned system it is much more baroque to understand the source and minix is much more accessible and straightforward for teaching these concepts

52697
minix	linux
pattern10	
i use and have used linux in production for 16 years and love it but since it s a production quality highly-tuned system it is much more baroque to understand the source and minix is much more accessible and straightforward for teaching these concepts

53386
ant	maven
pattern8	
the bottom line is that you might have a more direct comparison between ant and make automake--but not maven

54350
postgresql	mysql
pattern0	better	
postgresql implements character varying and text in the same manner toast tables - this approach most would argue is better than mysql

56384
width	height
pattern7	much bigger	
almost all monitors have an aspect ratio where width is much bigger than the height and yet almost all websites are designed exactly for the other way round

56384
width	height
pattern7	much bigger	
almost all monitors have an aspect ratio where width is much bigger than the height and yet almost all websites are designed exactly for the other way round

56384
width	height
pattern0	bigger	
almost all monitors have an aspect ratio where width is much bigger than the height and yet almost all websites are designed exactly for the other way round

61742
vim	emacs
pattern0	faster	
and while vi was getting kind of hoary vim has rejuvenated it and if anything it s growing feature-wise at least faster than emacs

62427
ati	nvidia
pattern0	
it was first released in 1995 when the world had much more than nvidia and ati directx vs opengl

62693
haskell	ocaml
pattern7	better	
but marketing is very important and haskell does it better than lisp or ocaml and competes for the same userbase

62693
haskell	ocaml
pattern7	better	
but marketing is very important and haskell does it better than lisp or ocaml and competes for the same userbase

63364
bazaar	git
pattern7	more	
i think the learning curve is much lighter for bazaar than git and bazaar has more structured support for different vcs layouts than git

63364
bazaar	git
pattern7	more structured	
i think the learning curve is much lighter for bazaar than git and bazaar has more structured support for different vcs layouts than git

65634
mouse	keyboard
pattern8	
this generally amounts to a more generous area with mouse selection or fewer keystrokes with keyboard selection

65634
mouse	keyboard
pattern0	fewer keystrokes	
this generally amounts to a more generous area with mouse selection or fewer keystrokes with keyboard selection

69697
lisp	scheme
pattern10	
my understanding however is that emacs lisp is fairly different from scheme and is also more procedural as opposed to functional

69697
lisp	scheme
pattern10	
my understanding however is that emacs lisp is fairly different from scheme and is also more procedural as opposed to functional

69704
haskell	ocaml
pattern7	poorer	
just learning haskell is poorer in that aspect though of course you could learn ocaml after haskell

69704
haskell	ocaml
pattern7	poorer	
just learning haskell is poorer in that aspect though of course you could learn ocaml after haskell

72634
cvs	svn
pattern7	
with some cvs svn it s harder to do with git it s trivial

72634
cvs	svn
pattern7	
with some cvs svn it s harder to do with git it s trivial

73044
hash	salt
pattern7	
use a secure hash when storing and verifying passwords and use a salt that is harder to guess

73044
hash	salt
pattern7	
use a secure hash when storing and verifying passwords and use a salt that is harder to guess

74188
int	boolean
pattern7	better	
if there are 20 bit columns non-null boolean is it better to explicitly hold them in an int type int32

74188
int	boolean
pattern7	better	
if there are 20 bit columns non-null boolean is it better to explicitly hold them in an int type int32

74412
perforce	svn
pattern0	
the merging and branching mechanisms work as good as any of the other source control systems better than svn in my experience and about as good as perforce but what really shines is the project tracking and project management aspects of the product and the built in automation for builds and deployments

74630
cvs	svn	bazaar	git	bazaar	cvs	bazaar	svn
pattern7	better	
as counter-intuitive as it sounds a distributed version control system mercurial git bazaar is better to start with than a centralized system svn cvs

74630
cvs	svn	bazaar	git	bazaar	cvs	bazaar	svn
pattern7	better	
as counter-intuitive as it sounds a distributed version control system mercurial git bazaar is better to start with than a centralized system svn cvs

74630
cvs	svn	bazaar	git	bazaar	cvs	bazaar	svn
pattern7	better	
as counter-intuitive as it sounds a distributed version control system mercurial git bazaar is better to start with than a centralized system svn cvs

74630
cvs	svn	bazaar	git	bazaar	cvs	bazaar	svn
pattern7	better	
as counter-intuitive as it sounds a distributed version control system mercurial git bazaar is better to start with than a centralized system svn cvs

75763
interpreted-language	compiled-language
pattern10	faster	
even if you can clearly measure that an application using a compiled-language is faster than an interpreted-language or vice versa the question still remains does it matter

75763
interpreted-language	compiled-language
pattern10	faster	
even if you can clearly measure that an application using a compiled-language is faster than an interpreted-language or vice versa the question still remains does it matter

75776
textmate	notepad++
pattern10	less	
notepad++ is less powerful than textmate for app programming but has interesting features for web development

75776
textmate	notepad++
pattern10	less powerful	
notepad++ is less powerful than textmate for app programming but has interesting features for web development

75776
textmate	notepad++
pattern8	less powerful	
notepad++ is less powerful than textmate for app programming but has interesting features for web development

78887
redmine	trac
pattern8	more flexible	
redmine on your own server - ruby nice more flexible than trac but have some minor youngness lacks

78887
redmine	trac
pattern8	
jira on your own server - java nice more complete than redmine but not as flexible as trac - but does manage multiple projects

81935
filesystems	ntfs
pattern0	more sense	
fourth linux filesystems make a lot more sense than ntfs

83851
cvs	svn
pattern10	
with centralized systems such as svn or cvs committing is more costly and it affects everyone

83851
cvs	svn
pattern10	
with centralized systems such as svn or cvs committing is more costly and it affects everyone

84407
lisp	scheme	lisp	prolog	scheme	prolog
pattern7	better	
i am kind of fond of prolog but i m not an ai programmer so i don t think i m qualified to judge for myself why prolog is better than lisp scheme

84407
lisp	scheme	lisp	prolog	scheme	prolog
pattern7	better	
i am kind of fond of prolog but i m not an ai programmer so i don t think i m qualified to judge for myself why prolog is better than lisp scheme

84407
lisp	scheme	lisp	prolog	scheme	prolog
pattern0	better	
i am kind of fond of prolog but i m not an ai programmer so i don t think i m qualified to judge for myself why prolog is better than lisp scheme

84407
lisp	scheme	lisp	prolog	scheme	prolog
pattern0	better	
i am kind of fond of prolog but i m not an ai programmer so i don t think i m qualified to judge for myself why prolog is better than lisp scheme

85869
perforce	svn
pattern0	better	
because svn is well svn and perforce from the one time 4 years back when comparing tools does some things better than svn

93045
lisp	scheme
pattern10	more	
scheme is the more functionally oriented of the two main lisp dialects smaller and purer than common lisp but less widely used in industry

93045
lisp	scheme
pattern10	more functionally	
scheme is the more functionally oriented of the two main lisp dialects smaller and purer than common lisp but less widely used in industry

93045
lisp	scheme
pattern0	
scheme is the more functionally oriented of the two main lisp dialects smaller and purer than common lisp but less widely used in industry

93183
getter	setter
pattern7	better	
is it better to manage this state in setter or is it better to do it in getter

93183
getter	setter
pattern7	better	
is it better to manage this state in setter or is it better to do it in getter

96467
pentaho	olap
pattern7	
to keep costs down we chose postgresql as the dwh database and pentaho enterprise as the bi olap analysis tool - we chose the paid version because the olap tool is much more user friendly

96467
pentaho	olap
pattern7	
to keep costs down we chose postgresql as the dwh database and pentaho enterprise as the bi olap analysis tool - we chose the paid version because the olap tool is much more user friendly

96943
bazaar	git
pattern0	better	
i don t know how many such rants i ve seen the last few weeks but they all seem to consider it as fact that mercurial and or bazaar are objectively better than git

97028
bazaar	git
pattern10	
and so they use git and recommend git and say things like git is better because it can do octopus merges so can bazaar or git is better because it is distributed so is any dvcs hence the name or git is better because it makes branching and merging easy again this is true of every dvcs

97028
bazaar	git
pattern10	
and so they use git and recommend git and say things like git is better because it can do octopus merges so can bazaar or git is better because it is distributed so is any dvcs hence the name or git is better because it makes branching and merging easy again this is true of every dvcs

97116
bazaar	git
pattern7	much easier	
git seems much easier to extend than bazaar and you don t have to use any one particular api to do it

97116
bazaar	git
pattern7	much easier	
git seems much easier to extend than bazaar and you don t have to use any one particular api to do it

97708
zeromq	qpid
pattern7	
and with the advent of much of the new peer-to-peer code like amqp rabbitmq qpid etc. and zeromq it s much easier to split threads across different process spaces and even machines and networks greatly simplifying things

97708
zeromq	qpid
pattern7	
and with the advent of much of the new peer-to-peer code like amqp rabbitmq qpid etc. and zeromq it s much easier to split threads across different process spaces and even machines and networks greatly simplifying things

110961
consistency	acid
pattern10	
definitely these are and should be uncommon otherwise it means the dbms lacks a lot of important types but on the other hand one should remember that a good db is acid compliant unlike an application and that anything related to consistency is better kept in there

110961
consistency	acid
pattern10	
definitely these are and should be uncommon otherwise it means the dbms lacks a lot of important types but on the other hand one should remember that a good db is acid compliant unlike an application and that anything related to consistency is better kept in there

112488
awt	swing
pattern7	older	
awt is older than swing and supports only a limited set of components

112488
awt	swing
pattern7	older	
awt is older than swing and supports only a limited set of components

112488
awt	swing
pattern0	older	
awt is older than swing and supports only a limited set of components

112488
awt	swing
pattern10	more	
swing is more modern as sun engineers learned from their awt mistakes and made something better albeit more complex

112488
awt	swing
pattern10	more modern	
swing is more modern as sun engineers learned from their awt mistakes and made something better albeit more complex

114078
vb.net	vb6
pattern10	more	
vb.net is more similar to vb6 and it should make it easier for

114078
vb.net	vb6
pattern10	more similar	
vb.net is more similar to vb6 and it should make it easier for

116105
jsf	seam
pattern7	
seems like that would be a good fit to me and imho jsf + seam is a pleasure to work with jsf is much easier than jsf and seam removes a large amount of boiler plate

116105
jsf	seam
pattern7	
seems like that would be a good fit to me and imho jsf + seam is a pleasure to work with jsf is much easier than jsf and seam removes a large amount of boiler plate

116105
jsf	seam
pattern0	
seems like that would be a good fit to me and imho jsf + seam is a pleasure to work with jsf is much easier than jsf and seam removes a large amount of boiler plate

116772
free	malloc
pattern0	
you re asking people who can t grasp that is better than malloc and free to learn something

118473
ienumerable	icollection
pattern10	more	
an icollection is more concrete than an ienumerable

118473
ienumerable	icollection
pattern10	more concrete	
an icollection is more concrete than an ienumerable

119683
argumentnullexception	argumentexception
pattern7	narrower	
argumentnullexception is narrower than argumentexception

119683
argumentnullexception	argumentexception
pattern7	narrower	
argumentnullexception is narrower than argumentexception

119683
argumentnullexception	argumentexception
pattern0	narrower	
argumentnullexception is narrower than argumentexception

120334
ant	maven
pattern0	easier	
maven s aim of convention over configuration means that two different projects will have very similar structure making transition between them much easier than with ant

120334
ant	maven
pattern0	easier	
maven s aim of convention over configuration means that two different projects will have very similar structure making transition between them much easier than with ant

122647
backbone.js	javascriptmvc
pattern10	much more	
but javascriptmvc is much more powerful in terms of features vs backbone.js or spine

122647
backbone.js	javascriptmvc
pattern10	much more powerful	
but javascriptmvc is much more powerful in terms of features vs backbone.js or spine

124085
free	malloc
pattern0	
the simple fact is that many if not most c++ users can hardly grasp that vector is better than malloc and free so the number who can not only appreciate but implement advanced template metaprogramming is not very high

124131
ant	maven
pattern10	more	
learning maven is more about learning concepts whereas learning ant is more about learning individual commands

124131
ant	maven
pattern10	more	
learning maven is more about learning concepts whereas learning ant is more about learning individual commands

124131
ant	maven
pattern10	
learning maven is more about learning concepts whereas learning ant is more about learning individual commands

124131
ant	maven
pattern10	
learning maven is more about learning concepts whereas learning ant is more about learning individual commands

124139
ant	maven
pattern10	more	
ant is more ancient than maven and does not handle as much

124139
ant	maven
pattern10	more ancient	
ant is more ancient than maven and does not handle as much

124139
ant	maven
pattern8	more ancient	
ant is more ancient than maven and does not handle as much

127588
google-chrome	firefox
pattern7	somehow less	
it s basically just a numbers game so users don t think firefox is somehow less good than google-chrome simply because google-chrome is version 16 and firefox is version 3.6

127588
google-chrome	firefox
pattern7	somehow less good	
it s basically just a numbers game so users don t think firefox is somehow less good than google-chrome simply because google-chrome is version 16 and firefox is version 3.6

127588
google-chrome	firefox
pattern0	less good	
it s basically just a numbers game so users don t think firefox is somehow less good than google-chrome simply because google-chrome is version 16 and firefox is version 3.6

128674
apache	nginx
pattern7	alot better	
which are two methods to simulate sockets over http they are way more efficient than polling and technically could scale to the 10k if you use a light weight server such as nginx which is alot better at handling concurent connections than apache

128674
apache	nginx
pattern7	alot better	
which are two methods to simulate sockets over http they are way more efficient than polling and technically could scale to the 10k if you use a light weight server such as nginx which is alot better at handling concurent connections than apache

128674
apache	nginx
pattern0	better	
as for the server with more than 100 connections you could get a amazon ec2 micro server instance for something like 19 month that lets you run nginx and could scale a lot better than apache

135706
jsf	wicket
pattern7	actually better	
some of the wicket guys have been saying things about jsf performance but according to this elaborate benchmark jsf actually performs better than wicket

135706
jsf	wicket
pattern7	actually better	
some of the wicket guys have been saying things about jsf performance but according to this elaborate benchmark jsf actually performs better than wicket

135706
jsf	wicket
pattern0	better	
some of the wicket guys have been saying things about jsf performance but according to this elaborate benchmark jsf actually performs better than wicket

137589
getter	setter
pattern0	
when i see a class having 50 or more fields containing not much more than getter and setter for these fields and the useless javadoc taking up more than half of the screen real estate i often end up removing it completely

137783
multiplying	add
pattern0	longer	
knowing that a multiplying takes a lot longer than an add

138903
profiling	debugging	profiling	instrumentation
pattern8	
something a bit more humane than debugging symbols or profiling instrumentation

139552
ada	pascal
pattern8	
bcpl begat b b begat c c begat c++ java d and a whole host of things considerably less well-thought-out than pascal and ada

139929
subtraction	add	subtraction	addition	subtract	add	subtract	addition
pattern8	
are more readable than add or subtract when performing addition and subtraction

141343
teamcity	jenkins
pattern0	
in my view though i ve somewhat less experience with jenkins than with teamcity both are excellent and very capable tools - i d be happy in an environment using either

141616
error-handling	try-catch
pattern7	more	
try-catch allows for more object-oriented error-handling as was mentioned by avoiding the use of magic numbers

141616
error-handling	try-catch
pattern7	more object-oriented	
try-catch allows for more object-oriented error-handling as was mentioned by avoiding the use of magic numbers

142340
for-loop	arrays
pattern0	
also you can help the optimizing compiler for example by making simple for-loop through an arrays with explicit start and end indices may allow the compiler to optimize away bound checking which is about the only thing that makes java arrays slower than native arrays

143942
free	malloc
pattern0	
something that nobody has mentioned yet is that the variable length array option is probably going to be vastly faster than malloc free since allocating a vla is just a case of adjusting the stack pointer in gcc at least

143942
free	malloc
pattern0	
something that nobody has mentioned yet is that the variable length array option is probably going to be vastly faster than malloc free since allocating a vla is just a case of adjusting the stack pointer in gcc at least

145841
min	max
pattern0	
this is done by setting a max and min variable to the first element of the array and for each element after that if that element is less than the min or greater than the max set the min or max to the new value

145841
min	max
pattern0	greater	
this is done by setting a max and min variable to the first element of the array and for each element after that if that element is less than the min or greater than the max set the min or max to the new value

145998
dbcontext	objectcontext
pattern0	
static variables tend to be even worse especially with objectcontext and dbcontext

146852
sctp	mtu
pattern0	bigger	
i wouldn t be surprised to see sendmsg work without issue but if you are using sctp in stream mode and sending buffers bigger than the mtu this may not remain true

147350
interpreted-language	compiled-language
pattern0	faster	
compiled-language are going to be faster than interpreted-language

148927
internationalization	localization
pattern7	
internationalization and localization is much easier on a .net project this with an inquiry from a huge canadian customer who would need both french and english versions may have tipped the balance for my client

148927
internationalization	localization
pattern7	
internationalization and localization is much easier on a .net project this with an inquiry from a huge canadian customer who would need both french and english versions may have tipped the balance for my client

149756
int	chars
pattern0	more	
int is 4 bytes in vb.net right and can store way more than 65k chars

150805
filesystems	ntfs
pattern10	
when comparing the ntfs filesystems and sql server 2005 blobs smaller than 256kb are more efficiently handled by sql server while ntfs is more efficient for blobs larger than 1mb

150805
filesystems	ntfs
pattern10	
when comparing the ntfs filesystems and sql server 2005 blobs smaller than 256kb are more efficiently handled by sql server while ntfs is more efficient for blobs larger than 1mb

150854
quicksort	timsort
pattern10	
according to these benchmarks in c# comparing the built-in quicksort to timsort timsort is significantly faster in the mostly sorted cases and slightly faster in the random data case and timsort gets better if the comparison function is particularly slow

150854
quicksort	timsort
pattern10	
according to these benchmarks in c# comparing the built-in quicksort to timsort timsort is significantly faster in the mostly sorted cases and slightly faster in the random data case and timsort gets better if the comparison function is particularly slow

150854
quicksort	timsort
pattern10	
according to these benchmarks in c# comparing the built-in quicksort to timsort timsort is significantly faster in the mostly sorted cases and slightly faster in the random data case and timsort gets better if the comparison function is particularly slow

150854
quicksort	timsort
pattern10	
according to these benchmarks in c# comparing the built-in quicksort to timsort timsort is significantly faster in the mostly sorted cases and slightly faster in the random data case and timsort gets better if the comparison function is particularly slow

150854
quicksort	timsort
pattern7	
according to these benchmarks in c# comparing the built-in quicksort to timsort timsort is significantly faster in the mostly sorted cases and slightly faster in the random data case and timsort gets better if the comparison function is particularly slow

150854
quicksort	timsort
pattern7	
according to these benchmarks in c# comparing the built-in quicksort to timsort timsort is significantly faster in the mostly sorted cases and slightly faster in the random data case and timsort gets better if the comparison function is particularly slow

159288
bellman-ford	dijkstra
pattern0	
it returns a numeric matrix. it is far slower than either dijkstra s or bellman-ford

159289
ocl	uml
pattern0	
they are no better or worse than uml s ocl but they re more easier to grasp perhaps but also less scientific

161429
int	chars
pattern0	smaller	
then size of a short int is at least 16 bits and not smaller than chars

163337
put	get
pattern0	more	
if you hate school you won t get more out than you put in

165268
children	parent
pattern7	object greater	
as i read in the documentation of heap data structure the algorithm compares the objects with existing nodes and places them in such a way that parent object is greater than the children

165268
children	parent
pattern7	object greater	
as i read in the documentation of heap data structure the algorithm compares the objects with existing nodes and places them in such a way that parent object is greater than the children

165268
children	parent
pattern0	greater	
as i read in the documentation of heap data structure the algorithm compares the objects with existing nodes and places them in such a way that parent object is greater than the children

165561
yacc	bison
pattern0	
he focuses on top-down recursive descent which let s face it is a lot easier than lex yacc or flex bison

166284
floating-point	integer
pattern0	slower	
floating-point is generally undesirable in hard-real-time applications both due to accumulation of error and the fact that fp computation is typically slower than integer arithmetic

167166
floating-point	integer	floating-point	fixed-point
pattern0	slower	
fixed-point numbers used to be popular when hardware floating-point units were uncommon or at least much slower than their integer counterparts

167166
floating-point	fixed-point
pattern0	slower	
while fixed-point numbers are somewhat easier to handle in terms of exactness if only because they are easier to reason about they are inferior to floats in pretty much every other regard - they have less precision a smaller range and because extra operations are needed to correct calculations for the implicit shift fixed-point math today is often slower than floating-point math

170448
division	modulo	division	multiplication	multiplication	modulo
pattern0	faster general	
multiplication division and modulo powers of 2 are much faster than general division

170662
octal	binary	octal	decimal
pattern0	easier	
octal fit real nicely on these displays and was easier than binary or decimal

171054
mvp	presenter
pattern7	mvvm slightly better	
that is mvp mvvm provides slightly better structure to solve this - presenter or view model are parts which know of the screen size

171054
mvp	presenter
pattern7	mvvm slightly better structure	
that is mvp mvvm provides slightly better structure to solve this - presenter or view model are parts which know of the screen size

172839
addition	multiplication	multiplying	addition	multiplying	multiplication
pattern7	still slower	
multiplying is still slower than addition on most cpus even if the difference has shrunk tremendously over the years so let s just count multiplication

172839
addition	multiplication	multiplying	addition	multiplying	multiplication
pattern7	still slower	
multiplying is still slower than addition on most cpus even if the difference has shrunk tremendously over the years so let s just count multiplication

172839
addition	multiplication	multiplying	addition	multiplying	multiplication
pattern0	slower	
multiplying is still slower than addition on most cpus even if the difference has shrunk tremendously over the years so let s just count multiplication

172913
gif	png
pattern10	
gif is kind of obsolete png is better

177051
tapestry	wicket
pattern0	
most likely if you have to develop just a wizard you should use something lighter and simpler than wicket tapestry rails or diango

177051
tapestry	wicket
pattern0	
most likely if you have to develop just a wizard you should use something lighter and simpler than wicket tapestry rails or diango

178184
jasmine	sinon
pattern7	more	
jasmine is more of a bdd framework and sinon the unit testing

178184
jasmine	sinon
pattern7	more	
jasmine is more of a bdd framework and sinon the unit testing

179403
feedback	review
pattern7	much slower	
instead of writing one test and then functionality you ll end up writing many tests and feedback is much slower since between review approvals it could take hours if not days

179403
feedback	review
pattern7	much slower	
instead of writing one test and then functionality you ll end up writing many tests and feedback is much slower since between review approvals it could take hours if not days

179403
feedback	review
pattern0	slower	
instead of writing one test and then functionality you ll end up writing many tests and feedback is much slower since between review approvals it could take hours if not days

180271
floating-point	integer
pattern0	
it is more complicated to write such filters though and if apply do more than one floating-point filter you ll get more rounding errors on each pass because you convert to and from integer every time

183725
boyer-moore	knuth-morris-pratt
pattern10	
i have heard some people saying that the fastest algorithm is boyer-moore and some saying that knuth-morris-pratt is actually faster

183729
cpu	hyperthreading
pattern7	
as a classic small example turning on hyperthreading on an intel cpu allows more processes to run at once -- but has a significant performance impact on the speed at which each individual process is executed

183729
cpu	hyperthreading
pattern7	
as a classic small example turning on hyperthreading on an intel cpu allows more processes to run at once -- but has a significant performance impact on the speed at which each individual process is executed

185218
clang	llvm
pattern8	
edit c++11 the long term viability of gcc is questioned -- if the developers refactor gcc and make it more toolable as llvm clang it might provide a good example

187396
postgresql	mysql
pattern7	probably easier	
mysql is probably easier to port an application to but postgresql is probably easier to port a data environment to..

187396
postgresql	mysql
pattern7	probably easier	
mysql is probably easier to port an application to but postgresql is probably easier to port a data environment to..

187396
postgresql	mysql
pattern7	
mysql is probably easier to port an application to but postgresql is probably easier to port a data environment to..

187396
postgresql	mysql
pattern7	
mysql is probably easier to port an application to but postgresql is probably easier to port a data environment to..

187888
getter	setter
pattern8	more common	
getter will almost always be more common than setter

189074
mouse	keyboard
pattern7	less	
i understand that computers are basically a complex system of electrical signatures that can calculate based on logic boards and some sort of gate mechanism but how do computers process something like if the number produced by the keyboard is less than 10 or if a mouse is clicked two times in a certain amount of time it equals a double click

189074
mouse	keyboard
pattern7	less	
i understand that computers are basically a complex system of electrical signatures that can calculate based on logic boards and some sort of gate mechanism but how do computers process something like if the number produced by the keyboard is less than 10 or if a mouse is clicked two times in a certain amount of time it equals a double click

194264
quicksort	heapsort
pattern7	lower	
quicksort has a lower constant factor than heapsort but it s worst case complexity is o n 2 so some variant switch back to heapsort in order to avoid that behavior for instance introsort but i m pretty sure i ve seen the idea applied in the early 90 s

194264
quicksort	heapsort
pattern7	lower constant	
quicksort has a lower constant factor than heapsort but it s worst case complexity is o n 2 so some variant switch back to heapsort in order to avoid that behavior for instance introsort but i m pretty sure i ve seen the idea applied in the early 90 s

194617
mergesort	heapsort	quicksort	mergesort	quicksort	heapsort
pattern10	less	
often times there will be a trade-off between time and space for example quicksort requires o log n extra memory while heapsort can use o 1 extra memory however the hidden constants in heapsort makes it less attractive there s also the stability issue which make mergesort more attractive if you don t mind payign the extra memory costs

194617
mergesort	heapsort	quicksort	mergesort	quicksort	heapsort
pattern10	less attractive	
often times there will be a trade-off between time and space for example quicksort requires o log n extra memory while heapsort can use o 1 extra memory however the hidden constants in heapsort makes it less attractive there s also the stability issue which make mergesort more attractive if you don t mind payign the extra memory costs

