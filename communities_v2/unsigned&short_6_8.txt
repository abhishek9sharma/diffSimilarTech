0---------------------------------------------------

alignment,narrower,int
alignment may fail as unsigned short can be narrower than unsigned int

c++,type,narrower,int,values
the rule for performing arithmetic operations in c c++ is that if the type such as short is narrower than int then it gets widened to int if all values can fit or unsigned int otherwise

int,implementations,smaller
as unsigned short int is in some implementations smaller than unsigned int

char,value,smaller,bigger
an unsigned char is an unsigned value which is typically smaller than and is guaranteed not to be bigger than a short

int,wider,size
so if you tell it to expect an unsigned short for example then it will actually expect either an int if int is wider than unsigned short or unsigned int if int and short are the same size

other---------------------------------------------------

x,0xdeadbeef,0xffff,0x0000ffff,comparison,smaller,value
but i wrote this code to check if we compared an signed int x 0xdeadbeef and unsigned short y 0xffff then after converting the unsigned short to int we should have 0x0000ffff in y at the comparison which should be smaller than the unsigned value of x

size_type,int,wider,lhs,addition
if size_type is defined as unsigned short and int is wider than unsigned short the lhs of your addition will be converted to the rhs and you rely on the addition being performed in the lhs s type

btw,processors,slower,int,c,standard,operations,types
btw on some processors unsigned short is much slower than unsigned int because the c standard requires that operations on unsigned types wrap

